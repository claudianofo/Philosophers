next:
-struct for each philosopher
-what is in each struct? 
-create a thread for each philosopher (perhaps rewatch code vault)
-how to handle forks and mutexes

printf("no_philo = %d\nttd = %d\ntte = %d\ntts = %d\nno_meals = %d\n", data->no_philo, data->time_to_die, data->time_to_eat, data->time_to_sleep, data->no_meals);


pthread:

pthread_create(thread(pthread_t), attr(NULL), routine(fnct that thread starts executing), arg(for routine))

Why are mutexes being initialised before threads created?
pthread_mutex(mutex(pthread_mutex_t), attr(0))
Mutexes are like a flag that prevents data from being either accessed or changed by other threads at the same time as the current thread. 
I think the mutex belongs to the data, not the thread. This is why the mutex can be initialised before the threads are initialised.
Worth noting, any process has at least one thread- but we only talk about the use of threads when there are multiple.

pthread_join(thread(pthread_t), returnValue(NULL I think))
I think this terminates the specified thread, by rejoining it with the main thread(IDK if that's right)

I have an array of t_philo, one entry for each philosopher. I need to allocate space for the array (which will point to each t_philo struct), so one for each philo. I also need to allocate space for each data entry inside each struct for each philospher

FORKS
Each philosopher requires a fork to be assigned to them. The forks could be their own struct, with an ID and a mutex
Each philosopher could have a left and right fork in their struct, and each fork will be accessible by 2 philosophers.
Mutex will be locked when a fork is in use which will prevent the other philosopher picking up the same fork.
I'm not sure how to check if the fork is locked before using. I think we probably just try to lock the mutex and if that doesn't work it is already lost.
I am going to give every philosopher a fork with the same ID on their right. That means that the fork on their left belongs to the philo on their left,
which will have the ID of -1 except for the case of philo 0. Their left fork will have the highest ID. 

OK, so what is next?
-Set up error handling for possible malloc failures, handle memory management
-create message display function, which takes philo id, time from start in milliseconds, and their current action
-add actions to routine (eating, sleeping, thinking, taking a fork), and add check for death to routine
-create a thread that monitors if any philosophers are dead
-create a function that keeps track of time from the start of the simulation, presumably using gettimeofday()

How do I structure the taking forks so that not everyone takes one at the same time? Do some philos start by sleeping or thinking instead?
How do I minimise the chance of philosophers dying?

So currently my timer is starting at the wrong time. I think the timer needs to start when the first action is taken.
How do we synch this and make sure there is one starting time for all of the threads?
Perhaps the start time needs a mutex? Wait, maybe it is starting at the right time. I think that I was calculating the elapsation of microseconds instead of milliseconds before
So now it is starting at 0.

What needs to be achieved here?
I should probably set up the routine properly. I'm confused about the relationship between eating, sleeping and thinking.
Can a philosopher only think after they have eaten and slept? How long do they have to think for to count?
I think I will start philosphers as either eating or thinking? Or Eating or sleeping?
Regardless, I want half of them eating and half of them doing either sleeping or thinking
Also, I don't think that they need to think for any particular amount of time, probably just until there are available forks?
They can begin by thinking if they're not eating and I think this is a good idea (as it makes more sense in the scenario) but I really don't think this is essential
How do I avoid a deadlock?
How do I maximise the chances of survival if there are an odd number of philosophers?

If there are even philos, it is really easy. Half of them start with thinking, the other half start with eating. They loop.
If there are an odd number, what happens really depends on the input params. If their time to eat and sleep are smaller than time to die by a significant enough margin, they will probably be fine

Ok so that wasn't so bad. Now I have to figure out how to monitor how recently each philosopher has eaten, and how it will be determined if one died, and what to do afterwards
Do I use a thread to monitor that? I think that's what I've heard of other people doing

I think I do need a monitoring thread, it will slow the philosophers down if their own threads have to do all of their own checking I think
What do we need for checking?
2 end conditions:
philosopher didn't eat in time
compare time elapsed since last meal with time_to_die
requires addition of last_meal (in millisec)
Is it best for philosophers to monitor this themselves? The monitor will have lots to check and I want to make sure that this is accurate. Would monitor still be accurate with 200 philos?


all philosophers ate enough
compare meals eaten with no_meals
requires addition of meals_eaten

How do I check for program finish more regularly?

MCOMBEAU
What does sim_stop_lock mutex do?
I think this is just so that the grim reaper doesn't change the sim_stop flag at the same time as one of the other threads checking it
what does write lock mutex do?
I think this might be to ensure that the threads aren't writing at the same time, which could help prevent them from getting mixed up. This could also ensure that nothing gets written after the death message
what does meal_time_lock mutex do?
this is part of the philo struct. It seems that it is being used when the last_meal data of that philo is being accessed. I assume this is so the grim reaper thread dosn't access it at the same time as the current thread.
This lock is also used for access/updates to times_ate variable


Use example 5 800 200 200 1

things i thought about/learnt
-The main thread (that creates the other threads) still exists while the other threads are busy
-You have to return a thread before it can join back with the main thread
-she deliberately sets the start time in the future in the function that creates the threads. Then the threads have to wait for the start time before they start and it is synced. Is this important?
-Could it just be that I need to check if the sim has stopped before notifying?
-She also checks not just once per loop, but also after eating notification but before updating times_ate

Things to do:
test for edgecases and implement anything necessary
consider setting up a start time for syncronisation
consider if the meal_time_lco and sim_stop_lock are worth doing
consider having an optional 2nd monitor thread in case program is too slow at higher numbers of philos
handle errors
handle memory management
make everything follow the norm
All functions in their correct files 
Upload correct files to intra git repo and submit

Edgecases to handle
???

Errors to handle
-malloc error
-pthread_create error
-mutex error

Memory management
-free malloc
-pthread join (already done)
-destory mutexes