next:
-struct for each philosopher
-what is in each struct? 
-create a thread for each philosopher (perhaps rewatch code vault)
-how to handle forks and mutexes

printf("no_philo = %d\nttd = %d\ntte = %d\ntts = %d\nno_meals = %d\n", data->no_philo, data->time_to_die, data->time_to_eat, data->time_to_sleep, data->no_meals);


pthread:

pthread_create(thread(pthread_t), attr(NULL), routine(fnct that thread starts executing), arg(for routine))

Why are mutexes being initialised before threads created?
pthread_mutex(mutex(pthread_mutex_t), attr(0))
Mutexes are like a flag that prevents data from being either accessed or changed by other threads at the same time as the current thread. 
I think the mutex belongs to the data, not the thread. This is why the mutex can be initialised before the threads are initialised.
Worth noting, any process has at least one thread- but we only talk about the use of threads when there are multiple.

pthread_join(thread(pthread_t), returnValue(NULL I think))
I think this terminates the specified thread, by rejoining it with the main thread(IDK if that's right)

I have an array of t_philo, one entry for each philosopher. I need to allocate space for the array (which will point to each t_philo struct), so one for each philo. I also need to allocate space for each data entry inside each struct for each philospher

FORKS
Each philosopher requires a fork to be assigned to them. The forks could be their own struct, with an ID and a mutex
Each philosopher could have a left and right fork in their struct, and each fork will be accessible by 2 philosophers.
Mutex will be locked when a fork is in use which will prevent the other philosopher picking up the same fork.
I'm not sure how to check if the fork is locked before using. I think we probably just try to lock the mutex and if that doesn't work it is already lost.
I am going to give every philosopher a fork with the same ID on their right. That means that the fork on their left belongs to the philo on their left,
which will have the ID of -1 except for the case of philo 0. Their left fork will have the highest ID. 

OK, so what is next?
-Set up error handling for possible malloc failures, handle memory management
-create message display function, which takes philo id, time from start in milliseconds, and their current action
-add actions to routine (eating, sleeping, thinking, taking a fork), and add check for death to routine
-create a thread that monitors if any philosophers are dead
-create a function that keeps track of time from the start of the simulation, presumably using gettimeofday()

How do I structure the taking forks so that not everyone takes one at the same time? Do some philos start by sleeping or thinking instead?
How do I minimise the chance of philosophers dying?